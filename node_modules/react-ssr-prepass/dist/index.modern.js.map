{"version":3,"file":"index.modern.js","sources":["../src/util.js","../src/index.js"],"sourcesContent":["// @flow\n\n/**\n * Copy all properties from `props` onto `obj`.\n * @param {object} obj Object onto which properties should be copied.\n * @param {object} props Object from which to copy properties.\n * @returns {object}\n * @private\n */\nexport function assign(obj /*: Object */, props /*: Object */) /*: Object */ {\n  for (let i in props) obj[i] = props[i];\n  return obj;\n}\n\n/**\n * Get flattened children from the children prop\n * @param {Array} accumulator\n * @param {any} children A `props.children` opaque object.\n * @returns {Array} accumulator\n * @private\n */\nexport function getChildren(\n  accumulator /*: Array<Object> */,\n  children /*: Array<Object> | Object */\n) /*: Array<Object> */ {\n  if (Array.isArray(children)) {\n    children.reduce(getChildren, accumulator);\n  } else if (children != null && children !== false) {\n    accumulator.push(children);\n  }\n  return accumulator;\n}\n","// @flow\nimport { assign, getChildren } from \"./util\";\nimport { options, Fragment, Component } from \"preact\";\nimport { Suspense } from \"preact/compat\";\n\nconst createContextDefaultValue = \"__p\";\nconst createContextDefaultValueNew = \"__\";\nconst _skipEffects = \"__s\";\n\n/*::\ntype VNode = {\n\ttype: string | Function,\n\tprops: Object,\n\t__c: typeof Component,\n};\n\ntype VNodes = VNode | Array<VNode>;\n\ntype Options = {\n\trender: (vnode: VNode) => void;\n};\n*/\n\nexport default function prepass(\n  vnode /*: VNode */,\n  visitor /*: ?(vnode: VNode, component: typeof Component) => ?Promise<any> */,\n  context /*: ?Object */\n) /*: Promise<any|Array<any>> */ {\n  // null, boolean, text, number \"vnodes\" need to prepassing...\n  if (vnode == null || typeof vnode !== \"object\") {\n    return Promise.resolve();\n  }\n\n  let nodeName = vnode.type,\n    props = vnode.props,\n    children = [];\n  context = context || {};\n\n  if (\n    typeof nodeName === \"function\" &&\n    nodeName !== Fragment &&\n    nodeName !== Suspense // We're handling Suspense the same way as we do fragments as we do not want something to catch promises during prepass\n  ) {\n    let doRender /* : () => Promise<void> */;\n    let c = (vnode.__c = new Component(props, context));\n    // initialize components in dirty state so setState() doesn't enqueue re-rendering:\n    c.__d = true;\n    c.__v = vnode;\n    /* istanbul ignore else */\n    if (c.state === undefined) {\n      c.state = {};\n    }\n\n    // options.render was renamed to _render (mangled to __r)\n    if (options.render) options.render(vnode);\n    if (options.__r) options.__r(vnode);\n\n    let isClassComponent = false;\n\n    // Necessary for createContext api. Setting this property will pass\n    // the context value as `this.context` just for this component.\n    let cxType = nodeName.contextType;\n    let provider = cxType && context[cxType.__c];\n    let cctx =\n      cxType != null\n        ? provider\n          ? provider.props.value\n          : cxType[createContextDefaultValue] ||\n            cxType[createContextDefaultValueNew]\n        : context;\n\n    if (\n      !nodeName.prototype ||\n      typeof nodeName.prototype.render !== \"function\"\n    ) {\n      // stateless functional components\n      doRender = () => {\n        try {\n          const previousSkipEffects = options[_skipEffects];\n          options[_skipEffects] = true;\n          const renderResult = Promise.resolve(\n            nodeName.call(vnode.__c, props, cctx)\n          );\n          options[_skipEffects] = previousSkipEffects;\n          return renderResult;\n        } catch (e) {\n          if (e && e.then) {\n            return e.then(doRender, doRender);\n          }\n\n          return Promise.reject(e);\n        }\n      };\n    } else {\n      isClassComponent = true;\n\n      // class-based components\n      // c = new nodeName(props, context);\n      c = vnode.__c = new nodeName(props, cctx);\n      // initialize components in dirty state so setState() doesn't enqueue re-rendering:\n      c.__d = true;\n      c.__v = vnode;\n      c.props = props;\n      c.context = cctx;\n      if (c.state === undefined) {\n        c.state = {};\n      }\n\n      // TODO: does react-ssr-prepass call the visitor before lifecycle hooks?\n      if (nodeName.getDerivedStateFromProps)\n        c.state = assign(\n          assign({}, c.state),\n          nodeName.getDerivedStateFromProps(c.props, c.state)\n        );\n      else if (c.componentWillMount) c.componentWillMount();\n\n      doRender = () => {\n        try {\n          return Promise.resolve(c.render(c.props, c.state, c.context));\n        } catch (e) {\n          if (e && e.then) {\n            return e.then(doRender, doRender);\n          }\n\n          return Promise.reject(e);\n        }\n      };\n    }\n\n    return (visitor\n      ? (\n          visitor(vnode, isClassComponent ? c : undefined) || Promise.resolve()\n        ).then(doRender)\n      : doRender()\n    ).then((rendered) => {\n      if (c.getChildContext) {\n        context = assign(assign({}, context), c.getChildContext());\n      }\n\n      if (Array.isArray(rendered)) {\n        return Promise.all(\n          rendered.map((node) => prepass(node, visitor, context))\n        );\n      }\n\n      return prepass(rendered, visitor, context);\n    });\n  }\n\n  if (props && getChildren((children = []), props.children).length) {\n    return Promise.all(\n      children.map((child) => prepass(child, visitor, context))\n    );\n  }\n\n  return Promise.resolve();\n}\n"],"names":["assign","obj","props","i","getChildren","accumulator","children","Array","isArray","reduce","push","prepass","vnode","visitor","context","Promise","resolve","nodeName","type","Fragment","Suspense","doRender","c","__c","Component","__d","__v","undefined","state","options","render","__r","isClassComponent","cxType","contextType","provider","cctx","value","prototype","getDerivedStateFromProps","componentWillMount","e","then","reject","previousSkipEffects","renderResult","call","rendered","getChildContext","all","map","node","length","child"],"mappings":"gHASgBA,EAAOC,EAAmBC,GACxC,IAAK,IAAIC,KAAKD,EAAOD,EAAIE,GAAKD,EAAMC,GACpC,OAAOF,WAUOG,EACdC,EACAC,GAOA,OALIC,MAAMC,QAAQF,GAChBA,EAASG,OAAOL,EAAaC,GACR,MAAZC,IAAiC,IAAbA,GAC7BD,EAAYK,KAAKJ,GAEZD,iBCPT,SAAwBM,EACtBC,EACAC,EACAC,GAGA,GAAa,MAATF,GAAkC,iBAAVA,EAC1B,OAAOG,QAAQC,UAGjB,IAAIC,EAAWL,EAAMM,KACnBhB,EAAQU,EAAMV,MACdI,EAAW,GAGb,GAFAQ,EAAUA,GAAW,GAGC,mBAAbG,GACPA,IAAaE,GACbF,IAAaG,EACb,CACA,IAAIC,EACAC,EAAKV,EAAMW,IAAM,IAAIC,EAAUtB,EAAOY,GAE1CQ,EAAEG,KAAM,EACRH,EAAEI,IAAMd,OAEQe,IAAZL,EAAEM,QACJN,EAAEM,MAAQ,IAIRC,EAAQC,QAAQD,EAAQC,OAAOlB,GAC/BiB,EAAQE,KAAKF,EAAQE,IAAInB,GAE7B,IAAIoB,GAAmB,EAInBC,EAAShB,EAASiB,YAClBC,EAAWF,GAAUnB,EAAQmB,EAAOV,KACpCa,EACQ,MAAVH,EACIE,EACEA,EAASjC,MAAMmC,MACfJ,EAAM,KACNA,EAAM,GACRnB,EA4DN,OAzDGG,EAASqB,WAC2B,mBAA9BrB,EAASqB,UAAUR,QAqB1BE,GAAmB,EAInBV,EAAIV,EAAMW,IAAM,IAAIN,EAASf,EAAOkC,GAEpCd,EAAEG,KAAM,EACRH,EAAEI,IAAMd,EACRU,EAAEpB,MAAQA,EACVoB,EAAER,QAAUsB,OACIT,IAAZL,EAAEM,QACJN,EAAEM,MAAQ,IAIRX,EAASsB,yBACXjB,EAAEM,MAAQ5B,EACRA,EAAO,GAAIsB,EAAEM,OACbX,EAASsB,yBAAyBjB,EAAEpB,MAAOoB,EAAEM,QAExCN,EAAEkB,oBAAoBlB,EAAEkB,qBAEjCnB,EAAW,KACT,IACE,OAAON,QAAQC,QAAQM,EAAEQ,OAAOR,EAAEpB,MAAOoB,EAAEM,MAAON,EAAER,UACpD,MAAO2B,GACP,OAAIA,GAAKA,EAAEC,KACFD,EAAEC,KAAKrB,EAAUA,GAGnBN,QAAQ4B,OAAOF,MAhD1BpB,EAAW,KACT,IACE,MAAMuB,EAAsBf,EAAO,IACnCA,EAAO,KAAiB,EACxB,MAAMgB,EAAe9B,QAAQC,QAC3BC,EAAS6B,KAAKlC,EAAMW,IAAKrB,EAAOkC,IAGlC,OADAP,EAAO,IAAiBe,EACjBC,EACP,MAAOJ,GACP,OAAIA,GAAKA,EAAEC,KACFD,EAAEC,KAAKrB,EAAUA,GAGnBN,QAAQ4B,OAAOF,MAuCpB5B,GAEFA,EAAQD,EAAOoB,EAAmBV,OAAIK,IAAcZ,QAAQC,WAC5D0B,KAAKrB,GACPA,KACFqB,KAAMK,IACFzB,EAAE0B,kBACJlC,EAAUd,EAAOA,EAAO,GAAIc,GAAUQ,EAAE0B,oBAGtCzC,MAAMC,QAAQuC,GACThC,QAAQkC,IACbF,EAASG,IAAKC,GAASxC,EAAQwC,EAAMtC,EAASC,KAI3CH,EAAQoC,EAAUlC,EAASC,KAItC,OAAIZ,GAASE,EAAaE,EAAW,GAAKJ,EAAMI,UAAU8C,OACjDrC,QAAQkC,IACb3C,EAAS4C,IAAKG,GAAU1C,EAAQ0C,EAAOxC,EAASC,KAI7CC,QAAQC"}